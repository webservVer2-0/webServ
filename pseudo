file open 후 read, write 직전에 kevent에 등록 !
- GET 먼저!!
- error part 건들 ㄴㄴ
- index.html은 open할 필요없이 copy만 해도 됨
- t_html의 entity_length_, entity 채워넣어서 chpark님께 전달해야함
- ServerInit.cpp 부분
- html에 요청 타입 체크 post일때
- file 타입이냐 cgi에 따라 두개로 나눌건지, 아니면 메소드에 따라 나눌건지 고민
- 레퍼런스 만들어주신대




t_error ClientGet(struct kevent* event) {

// 우선 클라이언트니까 형변환을 해줍니다.
s_client_type* client = static_cast<s_client_type*>(event->udata);

// request_msg의 init_line map에서 URI를 가져와서, c_str(const char*)로 바꿔줍니다.
const char* dir = client->request_msg->init_line.find("URI").c_str;

// open!! 
int req_fd = open(dir, O_RDONLY);

// 만약 여는걸 실패했으면, error stage나 t_error를 설정해줘요.
if (req_fd == -1) {
  error code set;
  return error_code?
}
fcntl([non block]); // 열고 나면 논블록 처리 해야합니다!

// 이벤트를 생성합니다.
s_work_type* work = client->CreateWork(dir, req_fd, 2);
ChangeEvent([tmp vector], req_fd, ... , work);
// stage 변경은 ChangeEvent 전 혹은 후에 들어갈 수 있습니다.
return error code;
}

t_error WorkGet(struct kevent* event) {

s_work_type* work = static_cast<work*>(event->udata);
int req_fd = work->GetFD();
size_t file_len = event->data->[file lenght] // 이게 data 어딘가에 있데요;
size_t read_ret = 0;

char* buf = work->client_ptr->response_msg->entity[file_len];  // response entity에 파일 길이만큼 할당하고서 여기에 읽어여.
// 이부분은 하류님이 추가적으로 함수를 작성해주셔서 t_http&에 작업을 해 줄 예정일것 같아요.
read_ret = read(req_fd, buf, file_len);
// 읽은 byte 수가 파일 길이랑 안맞으면 에러처리를 하겠죠?
if (read_ret != file_len) {
  error code set;
  여기서 할당 해제를 할지 말지는 모르겠어요;;
  return error code?
}
ChangeEvent([temp vector], req_fd, ... , [EV_DELETE], ... , NULL); // 여기 udata는 없을거 같네요.
// 클라이언트 이벤트 등록 부분도 하류님이 추가적으로 함수 작성을 해 주실껍니다.
ChangeEvent([temp vector], work->client_ptr->GetFD(), ..., ???); // 여기 udata는 뭔가 들어가야 할지도??
return error code;
}

GET
- client read event
- file read event

s_work_type 안에 t_http& 넣어주실예정


get { // switch? if?
  switch (GetStage())
  {
    case REQ_FIN:
      //파일 존재 여부 확인
      if (open() == -1) // 파일 존재 x
      {
       에러 처리
      }
      else // 파일 존재
      {
        SetStage(GET_READY);
        kevent로 등록 // udata에 work 등록 나중에 더 구체적으로
      }
    case GET_READY:
      파일 read (response용 entity 할당하고,
                read한거 s_client_type 안의 t_html response_msg_에 entity에 넣)
      (바이너리가 들어올수도 있으므로,)s_client_type의 t_html response_msg의 entity_length_에 길이까지 넣어준다
      파일 close;
      EV_DELETE (이벤트 삭제)
      ; if (POST) request entity 할당해제
      ; entity 전달 ?
      SetStage(GET_FINISH);
      changeevent(); // kevent 등록
  }
}

post {
  // CGI 작업이냐 아니냐에 따라 추가적으로 분기점이 생김 (s_stage enum 추가해야
  // 할지도 모름)
  if (POST_PAGE)
  {  // 페이지 POST라면,
    if (REQ_FIN)
    {
      1. entity 할당 
      2. 파일 만들기 open() 
      3. s_stage = POST_READY;
      return to kevent;
    }
    else if (POST_READY)
    {
      1. 파일 쓰기 
      2. close 
      3. 파일 오픈 
      4. s_stage = POST_SAVED;
      return to kevent;
    }
    else
    {  // POST_SAVED:
      1. 파일 사이즈 확인 
      2. close 
      3. s_stage = POST_FIN;
      4. response msg로 보낸다.
      return to kevent;
    }
  }
  else if (CGI)
  {  // cgi 요청이라면
    if (CGI_PIC) 
    {   // 사진 POST 라면
      if (REQ_FIN) 
      {
        1. entity 할당 
        2. 파일 만들기(fd open) 
        3. s_stage = PIC_READY;
        return to kevent;
      } 
      else if (PIC_READY) 
      {
        1. 파일 쓰기 
        2. 파이프 열기 
        3. client가 가진 ptr 수정 
        4. 이전 CGI_PIC POST fd 삭제 
        5. CGI_PIC 파일 close 
        6. 파이프 입력 close 
        7. s_stage = PIC_SAVED;
        8. fork하고 wait(-1) 
        9. '출력 파이프에서 읽기'를 kevent에 등록 ->return to kevent;
      } 
      else 
      {  // PIC_SAVED
        1. 출력 파이프로부터 값을 읽어옴 .
        2. entity에 저장 return to kevent;  // response msg로
      }
    } 
    else if (CGI_ASCII) 
    {  // 텍스트 POST 라면
      if (REQ_FIN) 
      {
        1. entity 할당 
        2. 파이프 열기 
        3. client가 가진 work ptr 수정 
        4. 이전 CGI_ASCII POST fd 삭제 
        6. 파이프 입력 close 
        7. s_stage = ASCII_SEND;
        8. fork하고 wait(-1) 
        9. '출력 파이프에서 읽기'를 kevent에 등록 ->return to kevent;
      } 
      else 
      {  // ASCII_RECIEVE;
        1. 출력 파이프로부터 값을 읽어옴 .
        2. entity에 저장 
        return to kevent;  // response msg로
      }
    }
  }
}

delete  // 어디에 DELETE_READY 설정?
{
  switch (GetStage())
  {
    case REQ_FIN:
		if (권한 있)  // delete 메서드에 대한 디렉 권한 검사.
						// tmp 경로인지 아닌지
		{
			if (파일 존재)
			{
				쿠키 id로 소유주 확인 삭제
			}
			else
			{
				// 클라이언트한테 파일 없다고 할지 / 그냥 파일
				// 지웠다고 보낼지
			}
		}
		else
		{
			// 클라이언트한테 권한 없다고 할지 / 그냥 파일
			// 지웠다고 보낼지
		}
		SetStage(DELETE_FIN);
		kevent 등록
    case DELETE_FIN:
		entity 전달
  }
}